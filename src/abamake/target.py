#!/usr/bin/python
# -*- coding: utf-8; mode: python; tab-width: 3; indent-tabs-mode: nil -*-
#
# Copyright 2013, 2014, 2015
# Raffaello D. Di Napoli
#
# This file is part of Abamake.
#
# Abamake is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Abamake is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
# the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along with Abamake. If not, see
# <http://www.gnu.org/licenses/>.
#---------------------------------------------------------------------------------------------------

"""Classes implementing different types of build target, each aware of how to build itself."""

import locale
import os
import re
import weakref

import abamake
import abamake.job
import abamake.tool


####################################################################################################
# Dependency

class Dependency(object):
   """Represents an abstract dependency with no additional information."""

   def __str__(self):
      return '({})'.format(type(self).__name__)

####################################################################################################
# NamedDependencyMixIn

class NamedDependencyMixIn(object):
   """Mixin that provides a name for a Dependency subclass."""

   # Dependency name.
   _m_sName = None

   def __init__(self, sName):
      """Constructor.

      str sName
         Dependency name.
      """

      if not sName:
         raise abamake.MakefileError('missing target name')
      self._m_sName = sName

   def __str__(self):
      return '{} ({})'.format(self._m_sName, type(self).__name__)

   def _get_name(self):
      return self._m_sName

   name = property(_get_name, doc = """Name of the dependency.""")

####################################################################################################
# FileDependencyMixIn

class FileDependencyMixIn(object):
   """Mixin that provides a file path for a Dependency subclass."""

   # Dependency file path.
   _m_sFilePath = None

   def __init__(self, sFilePath):
      """Constructor.

      str sFilePath
         Dependency file path.
      """

      if not sFilePath:
         raise abamake.MakefileError('missing target file path')
      self._m_sFilePath = os.path.normpath(sFilePath)

   def __str__(self):
      return '{} ({})'.format(self._m_sFilePath, type(self).__name__)

   def _get_file_path(self):
      return self._m_sFilePath

   file_path = property(_get_file_path, doc = """Path to the dependency file.""")

   def get_generated_files(self):
      """Returns a list containing the path of every file generated by this dependency.

      list(str+) return
         File path of each generated file.
      """

      # Only one generated file in this default implementation.
      return [self._m_sFilePath]

####################################################################################################
# ForeignDependency

class ForeignDependency(Dependency):
   """Abstract foreign dependency. Used by Target and its subclasses to represent files not built by
   Abamake.
   """

   pass

####################################################################################################
# ForeignSourceDependency

class ForeignSourceDependency(FileDependencyMixIn, ForeignDependency):
   """Foreign source file dependency."""

   pass

####################################################################################################
# ForeignLibDependency

class ForeignLibDependency(NamedDependencyMixIn, ForeignDependency):
   """Foreign library dependency. Supports libraries referenced only by name, as in their typical
   usage.
   """

   pass

####################################################################################################
# OutputRerefenceDependency

class OutputRerefenceDependency(FileDependencyMixIn, ForeignDependency):
   """File used as a reference to validate expected outputs."""

   pass

####################################################################################################
# UnitTestExecScriptDependency

class UnitTestExecScriptDependency(FileDependencyMixIn, ForeignDependency):
   """Executable that runs a unit test according to a “script”. Used to mimic interaction with a
   shell that Abamake does not implement.
   """

   pass

####################################################################################################
# Target

class Target(Dependency):
   """Abstract build target."""

   # Count of targets whose build is blocking this target’s build.
   _m_cBlockingDependencies = 0
   # Weak references to targets whose build is blocked by this target’s build.
   _m_setBlockedDependents = None
   # If True, the target is being built.
   _m_bBuilding = False
   # Dependencies (abamake.target.Dependency instances) for this target. Cannot be a set, because in
   # some cases (e.g. linker inputs) we need to keep it in order.
   # TODO: use an ordered set when one becomes available in “stock” Python?
   _m_listDependencies = None
   # Weak ref to the owning make instance.
   _m_mk = None
   # Mapping between Target subclasses and Abamakefile type IDs (XML element names). To add to this
   # mapping, decorate a derived class with @Target.makefile_type_id('xml-element-name').
   _sm_dictTypeIds = {}
   # If True, the target has been built or at least verified to be up-to-date.
   _m_bUpToDate = False

   def __init__(self, mk):
      """Constructor. Automatically registers the target with the specified Make instance.

      abamake.Make mk
         Make instance.
      """

      Dependency.__init__(self)

      self._m_setBlockedDependents = set()
      self._m_cBlockingDependencies = 0
      self._m_bBuilding = False
      self._m_listDependencies = []
      self._m_mk = weakref.ref(mk)
      self._m_bUpToDate = False
      mk.add_target(self)

   def add_dependency(self, dep):
      """Adds a target dependency.

      abamake.target.Dependency dep
         Dependency.
      """

      if dep not in self._m_listDependencies:
         self._m_listDependencies.append(dep)

   def _build_tool_run(self):
      """Enqueues any jobs necessary to unconditionally build the target."""

      mk = self._m_mk()
      log = mk.log
      log(log.HIGH, 'build[{}]: queuing build tool job(s)', self)
      # Instantiate the appropriate tool, and have it schedule any applicable jobs.
      job = self._get_tool().create_jobs(mk, self, self._on_build_tool_run_complete)
      mk.job_runner.enqueue(job)

   def _build_tool_should_run(self):
      """Checks if the target build tool needs to be run to freshen the target.

      bool return
         True if the build tool needs to be run, or False if the target is up-to-date.
      """

      mk = self._m_mk()
      return mk.force_build or mk.metadata.has_target_snapshot_changed(self)

   def _on_build_started(self):
      """Invoked after the target’s build is started."""

      log = self._m_mk().log
      # Regenerate any out-of-date dependency targets.
      listDependencyTargets = tuple(filter(
         lambda dep: isinstance(dep, Target), self._m_listDependencies
      ))
      log(log.HIGH, 'build[{}]: updating {} dependency targets', self, len(listDependencyTargets))
      if listDependencyTargets:
         self._m_cBlockingDependencies = len(listDependencyTargets)
         for tgtDependency in listDependencyTargets:
            tgtDependency.start_build(self)
      else:
         # No dependencies are blocking, continue with the build.
         self._on_dependencies_updated()

   def _on_build_tool_complete(self):
      """Invoked after the tool stage of the build has completed, regardless of whether a tool was
      really run.
      """

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: skipping metadata update', self)
      self._on_metadata_updated()

   def _on_build_tool_run_complete(self):
      """Invoked after the job that builds the target has completed its execution."""

      mk = self._m_mk()
      log = mk.log
      log(log.HIGH, 'build[{}]: updating metadata', self)
      if not mk.dry_run:
         # If the job was successfully executed, the target’s metadata can be updated.
         mk.metadata.update_target_snapshot(self)
      self._on_build_tool_complete()

   def _on_dependencies_updated(self):
      """Invoked after all the target’s dependencies have been updated."""

      mk = self._m_mk()
      log = mk.log
      log(log.HIGH, 'build[{}]: all dependencies up-to-date', self)
      # Now that the dependencies are up-to-date, check if any were rebuilt, causing this Target to
      # need to be rebuilt as well.
      if self._build_tool_should_run():
         self._build_tool_run()
      else:
         # There’s nothing to do, so just continue to the next stage.
         self._on_build_tool_complete()

   def _on_dependency_updated(self):
      """Invoked when the build of a dependency completes successfully."""

      log = self._m_mk().log
      self._m_cBlockingDependencies -= 1
      log(
         log.HIGH, 'build[{}]: 1 dependency updated, {} remaining',
         self, self._m_cBlockingDependencies
      )
      if self._m_cBlockingDependencies == 0:
         # All dependencies up-to-date, continue with the build.
         self._on_dependencies_updated()

   def _on_metadata_updated(self):
      """Invoked after the metadata for the target has been updated."""

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: unblocking dependents', self)
      # The target is built at this point, so its dependents can be unblocked.
      self._m_bUpToDate = True
      self._m_bBuilding = False
      for tgtDependent in self._m_setBlockedDependents:
         tgtDependent()._on_dependency_updated()
      self._m_setBlockedDependents = None
      log(log.HIGH, 'build[{}]: end', self)

   def dump_dependencies(self, sIndent = ''):
      """TODO: comment."""

      for dep in self._m_listDependencies:
         print(sIndent + str(dep))
         if isinstance(dep, Target):
            dep.dump_dependencies(sIndent + '  ')

   def get_dependencies(self, bTargetsOnly = False):
      """Iterates over the dependencies (abamake.target.Dependency instances) for this target.

      bool bTargetsOnly
         If True, only abamake.target.Target instances will be returned; if False, no filtering will
         occur.
      abamake.target.Dependency yield
         Dependency of this target.
      """

      for dep in self._m_listDependencies:
         if not bTargetsOnly or isinstance(dep, Target):
            yield dep

   def _get_tool(self):
      """Instantiates and configures the tool to build the target. Not used by Target, but offers a
      model for derived classes to follow.

      abamake.tool.Tool return
         Ready-to-use tool.
      """

      raise NotImplementedError('Target._get_tool() must be overridden in ' + type(self).__name__)

   class makefile_type_id(object):
      """Decorator to teach Target.select_subclass() the association of the decorated class with an
      Abamakefile type IDs (XML element name).

      str sNodeName
         Name of the element to associate with the decorated class.
      """

      def __init__(self, sNodeName):
         self._m_sNodeName = sNodeName

      def __call__(self, clsDerived):
         Target._sm_dictTypeIds[self._m_sNodeName] = clsDerived
         return clsDerived

   @classmethod
   def parse_makefile_element(cls, mk, elt):
      """Validates and processes the specified target XML element, throwing exceptions if any
      attributes have invalid values or if any required ones are missing. The element name as
      already been verified, but its attributes have not. Implementations should not descend into
      the contents of the source element.

      abamake.Make mk
         Make instance to associate to the returned Target.
      xml.dom.Element elt
         Element to parse.
      abamake.target.Target
         New Target instantiated from the contents of elt.
      """

      # Every target must have a name attribute.
      sName = elt.getAttribute('name')
      if not sName:
         raise MakefileSyntaxError('<{}>: missing “name” attribute'.format(elt.nodeName))
      # Instantiate the Target-derived class, assigning it its name.
      return cls(mk, sName)

   def parse_makefile_element_child(self, elt):
      """Validates and processes the specified child element of the target’s XML element.

      xml.dom.Element elt
         Element to parse.
      bool return
         True if elt was recognized and parsed, or False if it was not expected.
      """

      # Default implementation: expect no child elements.
      return False

   @classmethod
   def select_subclass(cls, eltTarget):
      """Returns the Target-derived class that should be instantiated to model the specified XML
      element.

      Subclasses declare their association to an XML element name by using the class decorator
      @Target.makefile_type_id('xml-element-name').

      xml.dom.Element eltTarget
         Element to parse.
      type return
         Model class for eltTarget.
      """

      return cls._sm_dictTypeIds.get(eltTarget.nodeName)

   def start_build(self, tgtDependent = None):
      """Begins building the target. Builds are asynchronous; use abamake.job.Runner.run() to allow
      them to complete.

      abamake.target.Target tgtDependent
         Target that will need to be unblocked when the build of this target completes. If self is
         already up-to-date, tgtDependent will be unblocked immediately.
      """

      log = self._m_mk().log
      if self._m_bUpToDate:
         log(log.HIGH, 'build[{}]: skipping', self)
         # Nothing to do, but make sure we unblock the dependent target that called this method.
         if tgtDependent:
            tgtDependent._on_dependency_updated()
      else:
         log(log.HIGH, 'build[{}]: begin', self)
         if tgtDependent:
            # Add the dependent target to those we’ll unblock when this build completes.
            self._m_setBlockedDependents.add(weakref.ref(tgtDependent))
         if not self._m_bBuilding:
            self._m_bBuilding = True
            self._on_build_started()

   def validate(self):
      """Checks that the target doesn’t have invalid settings that were undetectable by
      Target.parse_makefile_element_child().
      """

      pass

####################################################################################################
# NamedTargetMixIn

class NamedTargetMixIn(NamedDependencyMixIn):
   """Mixin that provides a name for a Target subclass."""

   def __init__(self, mk, sName):
      """See NamedDependencyMixIn.__init__(). Automatically registers the name => target association
      with the specified Make instance.

      abamake.Make mk
         Make instance.
      str sName
         Dependency name.
      """

      NamedDependencyMixIn.__init__(self, sName)

      mk.add_named_target(self, sName)

####################################################################################################
# FileTarget

class FileTarget(FileDependencyMixIn, Target):
   """Target that generates a file."""

   def __init__(self, mk, sFilePath):
      """See FileDependencyMixIn.__init__() and Target.__init__(). Automatically registers the path
      => target association with the specified Make instance.

      abamake.Make mk
         Make instance.
      str sFilePath
         Dependency file path.
      """

      FileDependencyMixIn.__init__(self, sFilePath)
      Target.__init__(self, mk)

      mk.add_file_target(self, self._m_sFilePath)

   def _get_build_log_path(self):
      return os.path.join(self._m_mk().output_dir, 'log', self._m_sFilePath + '.log')

   build_log_path = property(_get_build_log_path, doc = """
      Path to the file where the build log for this target (i.e. the captured stderr of the process
      that builds it) is saved.
   """)

####################################################################################################
# ProcessedSourceTarget

class ProcessedSourceTarget(FileTarget):
   """Intermediate target generated by processing a source file. The output file will be placed in
   the “int” directory relative to the output base directory.
   """

   # Target that that this target’s output will be linked into.
   _m_tgtFinalOutput = None
   # Source from which the target is built.
   _m_sSourceFilePath = None

   def __init__(self, mk, sSourceFilePath, sSuffix, tgtFinalOutput = None):
      """See FileTarget.__init__().

      abamake.Make mk
         Make instance.
      str sSourceFilePath
         Source from which the target is built.
      str sSuffix
         Suffix that is added to sSourceFilePath to generate the target’s file path.
      abamake.target.Target tgtFinalOutput
         Target that this target’s output will be linked into. If omitted, no output-driven
         configuration will be applied to the Tool instance generating this output.
      """

      FileTarget.__init__(self, mk, os.path.join(mk.output_dir, 'int', sSourceFilePath + sSuffix))

      self._m_sSourceFilePath = sSourceFilePath
      self._m_tgtFinalOutput = weakref.ref(tgtFinalOutput) if tgtFinalOutput else None
      self.add_dependency(ForeignSourceDependency(self._m_sSourceFilePath))
      # TODO: add other external dependencies.

####################################################################################################
# CxxPreprocessedTarget

class CxxPreprocessedTarget(ProcessedSourceTarget):
   """Preprocessed C++ source target."""

   def __init__(self, mk, sSourceFilePath, tgtFinalOutput = None):
      """See ProcessedSourceTarget.__init__()."""

      ProcessedSourceTarget.__init__(self, mk, sSourceFilePath, '.i', tgtFinalOutput)

   def _get_tool(self):
      """See ProcessedSourceTarget._get_tool()."""

      # TODO: refactor code shared with CxxObjectTarget._get_tool().

      mk = self._m_mk()

      cxx = mk.target_platform.get_tool(abamake.tool.CxxCompiler)
      cxx.output_file_path = self._m_sFilePath
      cxx.add_input(self._m_sSourceFilePath)

      if self._m_tgtFinalOutput:
         # Let the final output configure the compiler.
         self._m_tgtFinalOutput().configure_compiler(cxx)

      # Let the platform configure the compiler.
      mk.target_platform.configure_tool(cxx)

      # TODO: add file-specific flags.
      cxx.add_flags(abamake.tool.CxxCompiler.CFLAG_PREPROCESS_ONLY)
      return cxx

   def _on_build_started(self):
      """See ProcessedSourceTarget._on_build_started(). Overridden to start a job to collect
      implicit dependencies (those expressed in the source file via #include statements).
      """

      # TODO: refactor code shared with CxxObjectTarget._on_build_started().

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: gathering dependencies', self)
      # TODO: gather implicit dependencies by preprocessing the source, passing
      # self._on_implicit_dependencies_gathered as the on_complete handler, instead of doing this:
      self._on_implicit_dependencies_gathered()

   def _on_implicit_dependencies_gathered(self):
      """Invoked after the target’s implicit dependencies have been gathered."""

      # TODO: refactor code shared with CxxObjectTarget._on_implicit_dependencies_gathered().

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: dependencies gathered', self)
      # Resume with the ProcessedSourceTarget build step we hijacked.
      ProcessedSourceTarget._on_build_started(self)

####################################################################################################
# ObjectTarget

class ObjectTarget(ProcessedSourceTarget):
   """Intermediate object target."""

   pass

####################################################################################################
# CxxObjectTarget

class CxxObjectTarget(ObjectTarget):
   """C++ intermediate object target."""

   def __init__(self, mk, sSourceFilePath, tgtFinalOutput = None):
      """See ObjectTarget.__init__()."""

      ObjectTarget.__init__(
         self, mk, sSourceFilePath,
         mk.target_platform.get_tool(abamake.tool.CxxCompiler).object_suffix, tgtFinalOutput
      )

   def _get_tool(self):
      """See ObjectTarget._get_tool()."""

      # TODO: refactor code shared with CxxPreprocessedTarget._get_tool().

      mk = self._m_mk()

      cxx = mk.target_platform.get_tool(abamake.tool.CxxCompiler)
      cxx.output_file_path = self._m_sFilePath
      cxx.add_input(self._m_sSourceFilePath)

      if self._m_tgtFinalOutput:
         # Let the final output configure the compiler.
         self._m_tgtFinalOutput().configure_compiler(cxx)

      # Let the platform configure the compiler.
      mk.target_platform.configure_tool(cxx)

      # TODO: add file-specific flags.
      return cxx

   def _on_build_started(self):
      """See ObjectTarget._on_build_started(). Overridden to start a job to collect implicit
      dependencies (those expressed in the source file via #include statements).
      """

      # TODO: refactor code shared with CxxPreprocessedTarget._on_build_started().

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: gathering dependencies', self)
      # TODO: gather implicit dependencies by preprocessing the source, passing
      # self._on_implicit_dependencies_gathered as the on_complete handler, instead of doing this:
      self._on_implicit_dependencies_gathered()

   def _on_implicit_dependencies_gathered(self):
      """Invoked after the target’s implicit dependencies have been gathered."""

      # TODO: refactor code shared with CxxPreprocessedTarget._on_implicit_dependencies_gathered().

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: dependencies gathered', self)
      # Resume with the ObjectTarget build step we hijacked.
      ObjectTarget._on_build_started(self)

####################################################################################################
# BinaryTarget

class BinaryTarget(FileTarget):
   """Base class for binary (executable) target classes."""

   def configure_compiler(self, tool):
      """Configures the specified Tool instance to generate code suitable for linking in this
      target.

      abamake.tool.Tool tool
         Tool (compiler) to configure.
      """

      # TODO: e.g. configure Link Time Code Generation to match this target.
      pass

   def _get_tool(self):
      """See FileTarget._get_tool()."""

      mk = self._m_mk()

      lnk = mk.target_platform.get_tool(abamake.tool.Linker)
      lnk.output_file_path = self._m_sFilePath
      # TODO: add file-specific flags.

      # Let the platform configure the linker.
      mk.target_platform.configure_tool(lnk)

      # Scan this target’s dependencies for linker inputs.
      bOutputLibPathAdded = False
      # At this point all the dependencies are available, so add them as inputs.
      for dep in self._m_listDependencies:
         if isinstance(dep, ForeignLibDependency):
            # Strings go directly to the linker’s command line, assuming that they are external
            # libraries to link to.
            lnk.add_input_lib(dep.name)
         elif isinstance(dep, ObjectTarget):
            lnk.add_input(dep.file_path)
         elif isinstance(dep, DynLibTarget):
            lnk.add_input_lib(dep.name)
            # Since we’re linking to a library built by this makefile, make sure to add the output
            # “lib” directory to the library search path.
            if not bOutputLibPathAdded:
               lnk.add_lib_path(os.path.join(mk.output_dir, 'lib'))
               bOutputLibPathAdded = True

      # TODO: add other external dependencies.

      return lnk

   def parse_makefile_element_child(self, elt):
      """See FileTarget.parse_makefile_element_child()."""

      mk = self._m_mk()
      if elt.nodeName == 'source':
         # Pick the correct target class based on the file name extension.
         sFilePath = elt.getAttribute('path')
         if re.search(r'\.c(?:c|pp|xx)$', sFilePath):
            clsObjTarget = CxxObjectTarget
         else:
            raise abamake.MakefileError(
               '{}: unsupported source file type: {}'.format(self, sFilePath)
            )
         # Create an object target with the file path as its source.
         tgtObj = clsObjTarget(mk, sFilePath, self)
         self.add_dependency(tgtObj)
      elif elt.nodeName == 'dynlib':
         # Check if this makefile can build this dynamic library.
         sName = elt.getAttribute('name')
         # If the library is a known target (i.e. it’s built by this makefile), assign it as a
         # dependency of self; else just add the library name.
         dep = mk.get_named_target(sName, None)
         if not dep:
            dep = ForeignLibDependency(sName)
         self.add_dependency(dep)
      elif elt.nodeName in ('exeunittest', 'toolunittest'):
         # A unit test must be built after the target it’s supposed to test.
         sName = elt.getAttribute('name')
         tgtUnitTest = mk.get_named_target(sName, None)
         if not tgtUnitTest:
            raise abamake.TargetReferenceError(
               '{}: could not find definition of referenced unit test: {}'.format(self, sName)
            )
         tgtUnitTest.add_dependency(self)
      else:
         return FileTarget.parse_makefile_element_child(self, elt)
      return True

####################################################################################################
# NamedBinaryTarget

class NamedBinaryTarget(NamedTargetMixIn, BinaryTarget):
   """Base for named binary (executable) target classes."""

   def __init__(self, mk, sName, sFilePath):
      """See NamedTargetMixIn.__init__() and BinaryTarget.__init__().

      abamake.Make mk
         Make instance.
      str sName
         Target name.
      str sFilePath
         Target file path.
      """

      NamedTargetMixIn.__init__(self, mk, sName)
      BinaryTarget.__init__(self, mk, sFilePath)

####################################################################################################
# ExecutableTarget

@Target.makefile_type_id('exe')
class ExecutableTarget(NamedBinaryTarget):
   """Executable program target. The output file will be placed in the “bin” directory relative to
   the output base directory.
   """

   def __init__(self, mk, sName):
      """See NamedBinaryTarget.__init__().

      abamake.Make mk
         Make instance.
      str sName
         Target name.
      """

      NamedBinaryTarget.__init__(self, mk, sName, os.path.join(
         mk.output_dir, 'bin', mk.target_platform.exe_file_name(sName)
      ))

####################################################################################################
# DynLibTarget

@Target.makefile_type_id('dynlib')
class DynLibTarget(NamedBinaryTarget):
   """Dynamic library target. The output file will be placed in the “lib” directory relative to the
   output base directory.
   """

   def __init__(self, mk, sName):
      """See NamedBinaryTarget.__init__().

      abamake.Make mk
         Make instance.
      str sName
         Target name.
      """

      NamedBinaryTarget.__init__(self, mk, sName, os.path.join(
         mk.output_dir, 'lib', mk.target_platform.dynlib_file_name(sName)
      ))

   def configure_compiler(self, tool):
      """See NamedBinaryTarget.configure_compiler()."""

      if isinstance(tool, abamake.tool.CxxCompiler):
         # Make sure we’re generating code suitable for a dynamic library.
         tool.add_flags(abamake.tool.CxxCompiler.CFLAG_DYNLIB)
         # Allow building both a dynamic library and its clients using the same header file, by
         # changing “import” to “export” when this macro is defined.
         tool.add_macro(
            'ABAMAKE_BUILD_{}'.format(re.sub(r'[^_0-9A-Z]+', '_', self._m_sName.upper()))
         )

   def _get_tool(self):
      """See NamedBinaryTarget._get_tool(). Overridden to tell the linker to generate a dynamic
      library.
      """

      lnk = NamedBinaryTarget._get_tool(self)

      lnk.add_flags(abamake.tool.Linker.LDFLAG_DYNLIB)
      return lnk

####################################################################################################
# ToolUnitTestTarget

@Target.makefile_type_id('toolunittest')
class ToolUnitTestTarget(NamedTargetMixIn, Target):
   """Target that executes a unit test."""

   # True if comparison operands should be treated as amorphous BLOBs, or False if they should be
   # treated as strings.
   _m_bBinaryCompare = None
   # Filter (regex) to apply to the comparison operands.
   _m_reFilter = None

   def __init__(self, mk, sName):
      """See NamedTargetMixIn.__init__() and Target.__init__().

      abamake.Make mk
         Make instance.
      str sName
         Target name.
      """

      NamedTargetMixIn.__init__(self, mk, sName)
      Target.__init__(self, mk)

   def _build_tool_run(self):
      """See Target._build_tool_run()."""

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: no job to run for a ToolUnitTestTarget', self)
      self._on_build_tool_run_complete()

   def _on_build_tool_output_validated(self):
      """Invoked after the unit test’s output has been validated."""

      log = self._m_mk().log
      log(log.HIGH, 'build[{}]: tool output validated', self)
      # Resume with the Target build step we hijacked.
      Target._on_build_tool_run_complete(self)

   def _on_build_tool_run_complete(self):
      """See Target._on_build_tool_run_complete(). Overridden to perform any comparisons defined for
      the unit test.
      """

      mk = self._m_mk()
      log = mk.log
      log(log.HIGH, 'build[{}]: validating tool output', self)
      # Extract and transform the contents of the two dependencies to compare, and generate a
      # display name for them.
      listCmpNames = []
      listCmpOperands = []
      for dep in self._m_listDependencies:
         if isinstance(dep, (ProcessedSourceTarget, OutputRerefenceDependency)):
            # Add as comparison operand the contents of this dependency file.
            listCmpNames.append(dep.file_path)
            with open(dep.file_path, 'rb') as fileComparand:
               listCmpOperands.append(self._transform_comparison_operand(fileComparand.read()))

      # At this point we expect 0 <= len(listCmpOperands) <= 2, but we’ll check that a few more
      # lines below.
      if isinstance(listCmpOperands[0], str):
         sCmpV = 'internal:text-compare'
         sCmpQ = 'CMPTXT'
      else:
         sCmpV = 'internal:binary-compare'
         sCmpQ = 'CMPBIN'
      if log.verbosity >= log.LOW:
         log(log.LOW, '[{}] {} {}', sCmpV, *listCmpNames)
      else:
         log(log.QUIET, '{} {} <=> {}', log.qm_tool_name(sCmpQ), *listCmpNames)

      # Compare the targets.
      # TODO: make this asynchronously, passing self._on_build_tool_output_validated as the
      # on_complete handler for a new job, instead of doing this and the last line.
      bEqual = (listCmpOperands[0] == listCmpOperands[1])
      if not bEqual:
         log(log.QUIET, '{}: error: {} and {} differ', self._m_sName, *listCmpNames)
         # TODO: report build failure.
         return
      # This comparison counts as an additional test case with a single assertion.
      log.add_testcase_result(self._m_sName, 1, 0 if bEqual else 1)

      self._on_build_tool_output_validated()

   def parse_makefile_element_child(self, elt):
      """See Target.parse_makefile_element_child()."""

      mk = self._m_mk()
      if elt.nodeName in ('exeunittest', 'toolunittest'):
         raise abamake.MakefileSyntaxError('<unittest> not allowed in <unittest>')
      elif elt.nodeName == 'source' and elt.hasAttribute('tool'):
         # Due to specifying a non-default tool, this <source> does not generate an object file or
         # an executable.
         sFilePath = elt.getAttribute('path')
         sTool = elt.getAttribute('tool')
         # Pick the correct target class based on the file name extension and the tool to use.
         if re.search(r'\.c(?:c|pp|xx)$', sFilePath):
            if sTool == 'preproc':
               clsPreprocTarget = CxxPreprocessedTarget
            else:
               raise abamake.MakefileError(
                  '{}: unknown tool “{}” for source file: {}'.format(self, sTool, sFilePath)
               )
         else:
            raise abamake.MakefileError(
               '{}: unsupported source file type: {}'.format(self, sFilePath)
            )
         # Create a preprocessed target with the file path as its source.
         tgtObj = clsPreprocTarget(mk, sFilePath)
         # Note that we don’t invoke our add_dependency() override.
         Target.add_dependency(self, tgtObj)
      elif elt.nodeName == 'expected-output':
         dep = OutputRerefenceDependency(elt.getAttribute('path'))
         # Note that we don’t invoke our add_dependency() override.
         Target.add_dependency(self, dep)
      elif elt.nodeName == 'output-transform':
         sFilter = elt.getAttribute('filter')
         if sFilter:
            self._m_reFilter = re.compile(sFilter, re.DOTALL)
         else:
            raise abamake.MakefileError('{}: unsupported output transformation'.format(self))
      elif elt.nodeName == 'script':
         dep = UnitTestExecScriptDependency(elt.getAttribute('path'))
         # TODO: support <script name="…"> to refer to a program built by the same makefile.
         # TODO: support more attributes, such as command-line args for the script.
         # Note that we don’t invoke our add_dependency() override.
         Target.add_dependency(self, dep)
      return True

   def _transform_comparison_operand(self, oCmpOp):
      """Transforms a comparison operand according to any <output-transform> rules specified in the
      makefile, and returns the result.

      Some transformations require that the operand is a string; this method will convert a bytes
      instance into a str in a way that mimic what an io.TextIOBase object would do. This allows to
      automatically adjust to performing text-based comparisons (as opposed to bytes-based).

      object oCmpOp
         str or bytes instance to transform.
      object return
         Transformed comparison operand.
      """

      # TODO: refactor code shared with ExecutableUnitTestTarget._transform_comparison_operand().

      # Apply the only supported filter.
      # TODO: use an interface/specialization to apply different transformations.
      if self._m_reFilter:
         # This transformation requires that the operand is a string, so convert oCmpOp into one.
         if not isinstance(oCmpOp, str):
            oCmpOp = str(oCmpOp, encoding = locale.getpreferredencoding())
         oCmpOp = '\n'.join(self._m_reFilter.findall(oCmpOp))

      return oCmpOp

   def validate(self):
      """See Target.validate()."""

      Target.validate(self)

      # Count how many non-output (static) comparison operands have been specified for this target.
      cStaticCmpOperands = 0
      for dep in self._m_listDependencies:
         if isinstance(dep, (ProcessedSourceTarget, OutputRerefenceDependency)):
            cStaticCmpOperands += 1
      if cStaticCmpOperands != 2:
         raise abamake.MakefileError(
            '{}: need exactly two files/outputs to compare'.format(self)
         )

####################################################################################################
# ExecutableUnitTestTarget

@Target.makefile_type_id('exeunittest')
class ExecutableUnitTestTarget(NamedBinaryTarget):
   """Builds an executable unit test. The output file will be placed in the “bin/unittest” directory
   relative to the output base directory.
   """

   # True if comparison operands should be treated as amorphous BLOBS, or False if they should be
   # treated as strings.
   _m_bBinaryCompare = None
   # Filter (regex) to apply to the comparison operands.
   _m_reFilter = None
   # True if the unit test executable uses abc::testing to execute test cases and report their
   # results, making it compatible with being run via AbacladeUnitTestJob, or False if it’s a
   # monolithic single test, executed via ExternalCmdCapturingJob.
   #
   # TODO: make this a three-state, with True/False meaning explicit declaration, for example by
   # <unittest name="my-test" type="abc"> or type="exe", and None (default) meaning False with auto-
   # detect that can change to True using the current logic in add_dependency().
   _m_bUsesAbacladeTesting = None

   def __init__(self, mk, sName):
      """See NamedBinaryTarget.__init__().

      abamake.Make mk
         Make instance.
      str sName
         Target name.
      """

      NamedBinaryTarget.__init__(self, mk, sName, os.path.join(
         mk.output_dir, 'bin', 'unittest', mk.target_platform.exe_file_name(sName)
      ))

   def add_dependency(self, dep):
      """See NamedBinaryTarget.add_dependency(). Overridden to detect if the unit test is linked to
      abaclade-testing, making it compatible with being run via AbacladeUnitTestJob.
      """

      # Check if this unit test uses the abaclade-testing framework.
      if isinstance(dep, (ForeignLibDependency, DynLibTarget)):
         if dep.name == 'abaclade-testing':
            self._m_bUsesAbacladeTesting = True

      NamedBinaryTarget.add_dependency(self, dep)

   def get_exec_environ(self):
      """Generates an os.environ-like dictionary containing any variables necessary to execute the
      unit test.

      dict(str: str) return
         Modified environment, or None if no environment changes are needed to run the unit test.
      """

      # If the build target is linked to a library built by this same makefile, make sure we add
      # output_dir/lib to the library path.
      dictEnv = None
      if any(isinstance(dep, DynLibTarget) for dep in self._m_listDependencies):
         mk = self._m_mk()
         dictEnv = mk.target_platform.add_dir_to_dynlib_env_path(
            os.environ.copy(), os.path.join(mk.output_dir, 'lib')
         )
      return dictEnv

   def _on_build_tool_run_complete(self):
      """See NamedBinaryTarget._on_build_tool_run_complete(). Overridden to execute the freshly-
      built unit test.
      """

      mk = self._m_mk()
      log = mk.log
      log(log.HIGH, 'build[{}]: executing unit test', self)

      # Prepare the command line.
      for dep in self._m_listDependencies:
         if isinstance(dep, UnitTestExecScriptDependency):
            # We also have a “script” to drive the unit test.
            listArgs = [dep.file_path]
            # TODO: support more arguments once parse_makefile_element_child() can recognize them.
            break
      else:
         listArgs = []
      listArgs.append(self.file_path)

      # Prepare the arguments for Popen.
      dictPopenArgs = {
         'args': listArgs,
         'env' : self.get_exec_environ(),
      }
      # If we’re using a script to run this unit test, tweak the Popen invocation to run a possibly
      # non-executable file.
      if len(listArgs) > 1:
         mk.target_platform.adjust_popen_args_for_script(dictPopenArgs)

      # If the build target uses abc::testing, run it with the special abc::testing job,
      # AbacladeUnitTestJob.
      if self._m_bUsesAbacladeTesting:
         clsJob = abamake.job.AbacladeUnitTestJob
      else:
         clsJob = abamake.job.ExternalCmdCapturingJob
      # This will store stdout and stderr of the program to file, and will buffer stdout in
      # memory so we can use it in _on_build_tool_run_complete() if we need to, without disk access.
      job = clsJob(
         self._on_test_run_complete, ('TEST', self._m_sName), dictPopenArgs,
         mk.log, self.build_log_path, self.file_path + '.out'
      )
      mk.job_runner.enqueue(job)

   def _on_test_run_complete(self):
      """Invoked after the unit test has been run."""

      mk = self._m_mk()
      log = mk.log
      log(log.HIGH, 'build[{}]: updating dependencies', self)

      # Extract and transform the contents of the two dependencies to compare, and generate a
      # display name for them.
      listCmpNames = []
      listCmpOperands = []
      for dep in self._m_listDependencies:
         if isinstance(dep, OutputRerefenceDependency):
            # Add as comparison operand the contents of this dependency file.
            listCmpNames.append(dep.file_path)
            with open(dep.file_path, 'rb') as fileComparand:
               listCmpOperands.append(self._transform_comparison_operand(fileComparand.read()))

      # At this point we expect 0 <= len(listCmpOperands) <= 2, but we’ll check that a few more
      # lines below.
      if listCmpOperands:
         # We have a build target and at least another comparison operand, so the job that
         # just completed must be of type ExternalPipedCommandJob, and we’ll add its output as
         # comparison operand.
         listCmpNames.append(job.stdout_file_path)
         listCmpOperands.append(self._transform_comparison_operand(job.stdout))

         if isinstance(listCmpOperands[0], str):
            sCmpV = 'internal:text-compare'
            sCmpQ = 'CMPTXT'
         else:
            sCmpV = 'internal:binary-compare'
            sCmpQ = 'CMPBIN'
         if log.verbosity >= log.LOW:
            log(log.LOW, '[{}] {} {}', sCmpV, *listCmpNames)
         else:
            log(log.QUIET, '{} {} <=> {}', log.qm_tool_name(sCmpQ), *listCmpNames)

         # Compare the targets.
         bEqual = (listCmpOperands[0] == listCmpOperands[1])
         if not bEqual:
            log(log.QUIET, '{}: error: {} and {} differ', self._m_sName, *listCmpNames)
            iRet = 1
         # This comparison counts as an additional test case with a single assertion.
         log.add_testcase_result(self._m_sName, 1, 0 if bEqual else 1)
         if iRet != 0:
            # TODO: report build failure.
            return

      NamedBinaryTarget._on_build_tool_run_complete(self)

   def parse_makefile_element_child(self, elt):
      """See NamedBinaryTarget.parse_makefile_element_child()."""

      mk = self._m_mk()
      if elt.nodeName in ('exeunittest', 'toolunittest'):
         raise abamake.MakefileSyntaxError('<unittest> not allowed in <unittest>')
      elif elt.nodeName == 'expected-output':
         dep = OutputRerefenceDependency(elt.getAttribute('path'))
         # Note that we don’t invoke our add_dependency() override.
         NamedBinaryTarget.add_dependency(self, dep)
      elif elt.nodeName == 'output-transform':
         sFilter = elt.getAttribute('filter')
         if sFilter:
            self._m_reFilter = re.compile(sFilter, re.DOTALL)
         else:
            raise abamake.MakefileError('{}: unsupported output transformation'.format(self))
      elif elt.nodeName == 'script':
         dep = UnitTestExecScriptDependency(elt.getAttribute('path'))
         # TODO: support <script name="…"> to refer to a program built by the same makefile.
         # TODO: support more attributes, such as command-line args for the script.
         # Note that we don’t invoke our add_dependency() override.
         NamedBinaryTarget.add_dependency(self, dep)
      else:
         return NamedBinaryTarget.parse_makefile_element_child(self, elt)
      return True

   def _transform_comparison_operand(self, oCmpOp):
      """Transforms a comparison operand according to any <output-transform> rules specified in the
      makefile, and returns the result.

      Some transformations require that the operand is a string; this method will convert a bytes
      instance into a str in a way that mimic what an io.TextIOBase object would do. This allows to
      automatically adjust to performing text-based comparisons (as opposed to bytes-based).

      object oCmpOp
         str or bytes instance to transform.
      object return
         Transformed comparison operand.
      """

      # TODO: refactor code shared with ToolUnitTestTarget._transform_comparison_operand().

      # Apply the only supported filter.
      # TODO: use an interface/specialization to apply different transformations.
      if self._m_reFilter:
         # This transformation requires that the operand is a string, so convert oCmpOp into one.
         if not isinstance(oCmpOp, str):
            oCmpOp = str(oCmpOp, encoding = locale.getpreferredencoding())
         oCmpOp = '\n'.join(self._m_reFilter.findall(oCmpOp))

      return oCmpOp

   def validate(self):
      """See NamedBinaryTarget.validate()."""

      NamedBinaryTarget.validate(self)

      # Count how many non-output (static) comparison operands have been specified for this target.
      cStaticCmpOperands = 0
      for dep in self._m_listDependencies:
         if isinstance(dep, OutputRerefenceDependency):
            cStaticCmpOperands += 1
      if cStaticCmpOperands != 0 and cStaticCmpOperands != 1:
         # Expected a file against which to compare the unit test’s output.
         raise abamake.MakefileError(
            '{}: can’t compare the unit test output against more than one file'.format(self)
         )
