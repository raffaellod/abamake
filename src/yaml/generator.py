#!/usr/bin/python
# -*- coding: utf-8; mode: python; tab-width: 3; indent-tabs-mode: nil -*-
#
# Copyright 2016 Raffaello D. Di Napoli
#
# This file is part of Abamake.
#
# Abamake is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Abamake is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
# the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along with Abamake. If not, see
# <http://www.gnu.org/licenses/>.
#---------------------------------------------------------------------------------------------------

"""YAML generator."""

import collections
import datetime
import io
import re
import sys

import yaml

if sys.hexversion >= 0x03000000:
   basestring = str
   unistr = str
else:
   unistr = unicode


####################################################################################################

def generate_file(sFilePath, oRoot):
   """Generates and writes a YAML file from a Python object.

   str sFilePath
      Path to the YAML file.
   object oRoot
      Python object to be converted to YAML.
   """

   return Generator().generate_file(sFilePath, oRoot)

def generate_string(oRoot):
   """Generates a string containing YAML from a Python object.

   object oRoot
      Python object to be converted yo YAML.
   str return
      YAML source.
   """

   return Generator().generate_string(oRoot)

####################################################################################################

DOCUMENT_CONTEXT      = 1
SEQUENCE_CONTEXT      = 2
MAPPING_KEY_CONTEXT   = 3
MAPPING_VALUE_CONTEXT = 4

class Generator(object):
   """YAML generator. Currently limited to generating YAML that yaml.parser.Parser can recognize.

   This implementation supports local tags (!tag_name); these can be generated by including in the
   Python object structure instances of classes that define a method named __yaml__(self, yg), which
   will be invoked to generate the corresponding local tag. The __yaml__() method is supposed to
   invoke yg.write_*() methods on the Generator instance that it’s passed, potentially reentering
   with additional calls to yg.produce_from_object() to generate YAML for nested objects.
   """

   # Strings matching this don’t need to be enclosed in quotes.
   # TODO: this is too strict; find out the exact character set and fix this accordingly.
   _smc_reSafeString = re.compile('^[_A-Za-z][-_0-9A-Za-z]*$')

   def __init__(self):
      """Constructor."""

      self._m_bCanonical = False
      self._reset()

   def generate_file(self, sFilePath, oRoot):
      """Generates and writes a YAML file from a Python object.

      str sFilePath
         Path to the YAML file.
      object oRoot
         Python object to be converted to YAML.
      """

      self._reset()
      self._m_fileDst = io.open(sFilePath, 'wt', encoding = 'utf-8')
      try:
         self.write_doc_start()
         self.produce_from_object(oRoot)
      finally:
         self._m_fileDst.close()
         self._m_fileDst = None

   def generate_string(self, oRoot):
      """Generates a string containing YAML from a Python object.

      object oRoot
         Python object to be converted yo YAML.
      str return
         YAML source.
      """

      self._reset()
      self._m_fileDst = io.StringIO()
      try:
         self.write_doc_start()
         self.produce_from_object(oRoot)
         s = self._m_fileDst.getvalue()
      finally:
         self._m_fileDst = None
      return s

   def new_line(self):
      self._m_fileDst.write(u'\n')
      self._m_bAtBOL = True

   def write_doc_start(self):
      """TODO: comment."""

      self._m_fileDst.write(u'%YAML 1.2')
      self.new_line()
      self._m_fileDst.write(u'---')
      self._m_bAtBOL = False

   def write_mapping_begin(self, sTag):
      """To be called by a YAML-friendly class’s __yaml__() method.

      str sTag
         YAML tag.
      """

      if sTag:
         # TODO: validate the format of sTag.

         if sys.hexversion < 0x03000000 and not isinstance(sTag, unicode):
            sTag = unicode(sTag)
         self._m_fileDst.write(sTag)

      self.new_line()
      self._m_iLevel += 1
      self._m_listContextStack.append(self._m_iContext)
      self._m_iContext = MAPPING_KEY_CONTEXT

   def write_mapping_end(self):
      """To be called by a YAML-friendly class’s __yaml__() method."""

      # TODO: validate self._m_iContext.
      self._m_iContext = self._m_listContextStack.pop()
      self._m_iLevel -= 1

   def write_scalar(self, sTag, sYaml):
      """Writes a scalar object. To be called by a YAML-friendly class’s __yaml__() method.

      str sTag
         YAML tag.
      str sYaml
         Object in YAML notation.
      """

      # TODO: validate the format of sTag.
      # TODO: validate that sYaml is a string.

      if sys.hexversion < 0x03000000:
         # Ensure that everything is Unicode.
         if not isinstance(sTag, unicode):
            sTag = unicode(sTag)
         if not isinstance(sYaml, unicode):
            sYaml = unicode(sYaml)

      # TODO: possibility for a bunch of optimizations right now.

      self._m_fileDst.write(sTag)
      if sYaml:
         self._m_fileDst.write(u' ')
         self._m_fileDst.write(sYaml)

   def write_sequence_begin(self, sTag):
      """To be called by a YAML-friendly class’s __yaml__() method.

      str sTag
         YAML tag.
      """

      if sTag:
         # TODO: validate the format of sTag.

         if sys.hexversion < 0x03000000 and not isinstance(sTag, unicode):
            sTag = unicode(sTag)
         self._m_fileDst.write(sTag)

      self.new_line()
      self._m_iLevel += 1
      self._m_listContextStack.append(self._m_iContext)
      self._m_iContext = SEQUENCE_CONTEXT

   def write_sequence_end(self):
      """To be called by a YAML-friendly class’s __yaml__() method."""

      # TODO: validate self._m_iContext.
      self._m_iContext = self._m_listContextStack.pop()
      self._m_iLevel -= 1

   def produce_from_object(self, o):
      """Generates YAML for the specified object.

      object o
         Object to generate YAML for.
      """

      iContext = self._m_iContext
      if self._m_bAtBOL:
         if self._m_iLevel > 1:
            self._m_fileDst.write(u'  ' * (self._m_iLevel - 1))
         self._m_bAtBOL = False
      if iContext == SEQUENCE_CONTEXT:
         self._m_fileDst.write(u'- ')
      elif iContext == MAPPING_KEY_CONTEXT:
         pass
      elif iContext == MAPPING_VALUE_CONTEXT:
         self._m_fileDst.write(u': ')
      elif iContext == DOCUMENT_CONTEXT:
         self._m_fileDst.write(u' ')

      try:
         fnYaml = o.__yaml__
      except AttributeError:
         fnYaml = None
      if fnYaml:
         fnYaml(self)
         if self._m_iContext != iContext:
            # TODO: error in o.__yaml__().
            pass
      else:
         if o is None:
            self.write_scalar(u'!!null', u'')
         elif isinstance(o, basestring):
            if sys.hexversion < 0x03000000 and not isinstance(o, unicode):
               sYaml = unicode(o)
            else:
               sYaml = o
            if self._m_bCanonical or self._smc_reSafeString.match(sYaml):
               # The string doesn’t need quotes or an explicit tag.
               self._m_fileDst.write(sYaml)
            else:
               # The string needs quotes.
               # TODO: escape characters and quotes in sYaml.
               self.write_scalar(u'!!str', u'"{}"'.format(sYaml))
         elif isinstance(o, int):
            sYaml = unistr(o)
            if self._m_bCanonical:
               self.write_scalar(u'!!int', sYaml)
            else:
               self._m_fileDst.write(sYaml)
         elif isinstance(o, bool):
            sYaml = u'true' if o else u'false'
            if self._m_bCanonical:
               self.write_scalar(u'!!bool', sYaml)
            else:
               self._m_fileDst.write(sYaml)
         elif isinstance(o, datetime.datetime):
            sYaml = o.isoformat()
            if self._m_bCanonical:
               self.write_scalar(u'!!timestamp', sYaml)
            else:
               self._m_fileDst.write(sYaml)
         elif isinstance(o, collections.Mapping):
            # Force generating a tag if the mapping is empty, otherwise we’d generate just nothing.
            if self._m_bCanonical:
               self.write_mapping_begin(u'!!map')
            else:
               self.write_mapping_begin(None)
            for oKey, oValue in o.items():
               self.produce_from_object(oKey)
               self.produce_from_object(oValue)
            self.write_mapping_end()
         elif isinstance(o, collections.Iterable):
            # Force generating a tag if the sequence is empty, otherwise we’d generate just nothing.
            if self._m_bCanonical:
               self.write_sequence_begin(u'!!seq')
            else:
               self.write_sequence_begin(None)
            for oElement in o:
               self.produce_from_object(oElement)
            self.write_sequence_end()
         elif isinstance(o, float):
            sYaml = unistr(o)
            if self._m_bCanonical:
               self.write_scalar(u'!!float', sYaml)
            else:
               self._m_fileDst.write(sYaml)
         else:
            raise TypeError('unsupported type: {}'.format(type(o).__name__))

      if iContext == SEQUENCE_CONTEXT:
         self.new_line()
      elif iContext == MAPPING_KEY_CONTEXT:
         self._m_iContext = MAPPING_VALUE_CONTEXT
      elif iContext == MAPPING_VALUE_CONTEXT:
         self._m_iContext = MAPPING_KEY_CONTEXT
         self.new_line()
      elif iContext == DOCUMENT_CONTEXT:
         self.new_line()

   def _reset(self):
      """Reinitializes the internal generator status."""

      self._m_bAtBOL = True
      self._m_iContext = DOCUMENT_CONTEXT
      self._m_listContextStack = []
      self._m_fileDst = None
      self._m_iLevel = 0
