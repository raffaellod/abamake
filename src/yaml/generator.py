#!/usr/bin/python
# -*- coding: utf-8; mode: python; tab-width: 3; indent-tabs-mode: nil -*-
#
# Copyright 2016-2017 Raffaello D. Di Napoli
#
# This file is part of Complemake.
#
# Complemake is free software: you can redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# Complemake is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with Complemake. If not, see
# <http://www.gnu.org/licenses/>.
#-------------------------------------------------------------------------------------------------------------

"""YAML generator."""

import collections
import datetime
import io
import re
import sys

import yaml

if sys.hexversion >= 0x03000000:
   basestring = str
   unistr = str
else:
   unistr = unicode


##############################################################################################################

def generate_file(file_path, root):
   """Generates and writes a YAML file from a Python object.

   str file_path
      Path to the YAML file.
   object root
      Python object to be converted to YAML.
   """

   return Generator().generate_file(file_path, root)

def generate_string(root):
   """Generates a string containing YAML from a Python object.

   object root
      Python object to be converted yo YAML.
   str return
      YAML source.
   """

   return Generator().generate_string(root)

##############################################################################################################

_DOCUMENT_CONTEXT      = 1
_SEQUENCE_CONTEXT      = 2
_MAPPING_KEY_CONTEXT   = 3
_MAPPING_VALUE_CONTEXT = 4

class Generator(object):
   """YAML generator. Currently limited to generating YAML that yaml.parser.Parser can recognize.

   This implementation supports local tags (!tag_name); these can be generated by including in the Python
   object structure instances of classes that define a method named __yaml__(self, yg), which will be invoked
   to generate the corresponding local tag. The __yaml__() method is supposed to invoke yg.write_*() methods
   on the Generator instance that it’s passed, potentially reentering with additional calls to
   yg.produce_from_object() to generate YAML for nested objects.
   """

   # Strings matching this don’t need to be enclosed in quotes.
   # TODO: this is too strict; find out the exact character set and fix this accordingly.
   _safe_string_re = re.compile('^[_A-Za-z][-_0-9A-Za-z]*$')

   def __init__(self):
      """Constructor."""

      self._canonical = False
      self._reset()

   def generate_file(self, file_path, root):
      """Generates and writes a YAML file from a Python object.

      str file_path
         Path to the YAML file.
      object root
         Python object to be converted to YAML.
      """

      self._reset()
      self._dst_file = io.open(file_path, 'wt', encoding = 'utf-8')
      try:
         self.write_doc_start()
         self.produce_from_object(root)
      finally:
         self._dst_file.close()
         self._dst_file = None

   def generate_string(self, root):
      """Generates a string containing YAML from a Python object.

      object root
         Python object to be converted yo YAML.
      str return
         YAML source.
      """

      self._reset()
      self._dst_file = io.StringIO()
      try:
         self.write_doc_start()
         self.produce_from_object(root)
         s = self._dst_file.getvalue()
      finally:
         self._dst_file = None
      return s

   def new_line(self):
      self._dst_file.write(u'\n')
      self._at_bol = True

   def write_doc_start(self):
      """TODO: comment."""

      self._dst_file.write(u'%YAML 1.2')
      self.new_line()
      self._dst_file.write(u'---')
      self._at_bol = False

   def write_mapping_begin(self, tag):
      """To be called by a YAML-friendly class’s __yaml__() method.

      str tag
         YAML tag.
      """

      if tag:
         # TODO: validate the format of tag.

         if sys.hexversion < 0x03000000 and not isinstance(tag, unicode):
            tag = unicode(tag)
         self._dst_file.write(tag)

      self.new_line()
      self._level += 1
      self._context_stack.append(self._context)
      self._context = _MAPPING_KEY_CONTEXT

   def write_mapping_end(self):
      """To be called by a YAML-friendly class’s __yaml__() method."""

      # TODO: validate self._context.
      self._context = self._context_stack.pop()
      self._level -= 1

   def write_scalar(self, tag, s):
      """Writes a scalar object. To be called by a YAML-friendly class’s __yaml__() method.

      str tag
         YAML tag.
      str s
         Object in YAML notation.
      """

      # TODO: validate the format of tag.
      # TODO: validate that s is a string.

      if sys.hexversion < 0x03000000:
         # Ensure that everything is Unicode.
         if not isinstance(tag, unicode):
            tag = unicode(tag)
         if not isinstance(s, unicode):
            s = unicode(s)

      # TODO: possibility for a bunch of optimizations right now.

      self._dst_file.write(tag)
      if s:
         self._dst_file.write(u' ')
         self._dst_file.write(s)

   def write_sequence_begin(self, tag):
      """To be called by a YAML-friendly class’s __yaml__() method.

      str tag
         YAML tag.
      """

      if tag:
         # TODO: validate the format of tag.

         if sys.hexversion < 0x03000000 and not isinstance(tag, unicode):
            tag = unicode(tag)
         self._dst_file.write(tag)

      self.new_line()
      self._level += 1
      self._context_stack.append(self._context)
      self._context = _SEQUENCE_CONTEXT

   def write_sequence_end(self):
      """To be called by a YAML-friendly class’s __yaml__() method."""

      # TODO: validate self._context.
      self._context = self._context_stack.pop()
      self._level -= 1

   def produce_from_object(self, o):
      """Generates YAML for the specified object.

      object o
         Object to generate YAML for.
      """

      context = self._context
      if self._at_bol:
         if self._level > 1:
            self._dst_file.write(u'  ' * (self._level - 1))
         self._at_bol = False
      if context == _SEQUENCE_CONTEXT:
         self._dst_file.write(u'- ')
      elif context == _MAPPING_KEY_CONTEXT:
         pass
      elif context == _MAPPING_VALUE_CONTEXT:
         self._dst_file.write(u': ')
      elif context == _DOCUMENT_CONTEXT:
         self._dst_file.write(u' ')

      try:
         yaml_fn = o.__yaml__
      except AttributeError:
         yaml_fn = None
      if yaml_fn:
         yaml_fn(self)
         if self._context != context:
            # TODO: error in o.__yaml__().
            pass
      else:
         if o is None:
            self.write_scalar(u'!!null', u'')
         elif isinstance(o, basestring):
            if sys.hexversion < 0x03000000 and not isinstance(o, unicode):
               s = unicode(o)
            else:
               s = o
            if self._canonical or self._safe_string_re.match(s):
               # The string doesn’t need quotes or an explicit tag.
               self._dst_file.write(s)
            else:
               # The string needs quotes.
               # TODO: escape characters and quotes in s.
               self.write_scalar(u'!!str', u'"{}"'.format(s))
         elif isinstance(o, int):
            s = unistr(o)
            if self._canonical:
               self.write_scalar(u'!!int', s)
            else:
               self._dst_file.write(s)
         elif isinstance(o, bool):
            s = u'true' if o else u'false'
            if self._canonical:
               self.write_scalar(u'!!bool', s)
            else:
               self._dst_file.write(s)
         elif isinstance(o, datetime.datetime):
            s = unistr(o.isoformat())
            if self._canonical:
               self.write_scalar(u'!!timestamp', s)
            else:
               self._dst_file.write(s)
         elif isinstance(o, collections.Mapping):
            if self._canonical:
               self.write_mapping_begin(u'!!map')
            else:
               self.write_mapping_begin(None)
            for key, value in o.items():
               self.produce_from_object(key)
               self.produce_from_object(value)
            self.write_mapping_end()
         elif isinstance(o, collections.Iterable):
            if self._canonical:
               self.write_sequence_begin(u'!!seq')
            else:
               self.write_sequence_begin(None)
            for element in o:
               self.produce_from_object(element)
            self.write_sequence_end()
         elif isinstance(o, float):
            s = unistr(o)
            if self._canonical:
               self.write_scalar(u'!!float', s)
            else:
               self._dst_file.write(s)
         else:
            raise TypeError('unsupported type: {}'.format(type(o).__name__))

      if context == _SEQUENCE_CONTEXT:
         self.new_line()
      elif context == _MAPPING_KEY_CONTEXT:
         self._context = _MAPPING_VALUE_CONTEXT
      elif context == _MAPPING_VALUE_CONTEXT:
         self._context = _MAPPING_KEY_CONTEXT
         self.new_line()
      elif context == _DOCUMENT_CONTEXT:
         self.new_line()

   def _reset(self):
      """Reinitializes the internal generator status."""

      self._at_bol = True
      self._context = _DOCUMENT_CONTEXT
      self._context_stack = []
      self._dst_file = None
      self._level = 0
