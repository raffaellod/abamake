typedef-name:
   identifier
namespace-name:
   original-namespace-name
   namespace-alias
original-namespace-name:
   identifier
namespace-alias:
   identifier
class-name:
   identifier
   simple-template-id
enum-name:
   identifier
template-name:
   identifier
hex-quad:
   hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
universal-character-name:
   \u hex-quad
   \U hex-quad hex-quad
preprocessing-token:
   header-name
   identifier
   pp-number
   character-literal
   user-defined-character-literal
   string-literal
   user-defined-string-literal
   preprocessing-op-or-punc
   each non-white-space character that cannot be one of the above
token:
   identifier
   keyword
   literal
   operator
   punctuator
header-name:
   < h-char-sequence >
   " q-char-sequence "
   h-char-sequence:
   h-char
   h-char-sequence h-char
h-char:
   any member of the source character set except new-line and >
q-char-sequence:
   q-char
   q-char-sequence q-char
q-char:
   any member of the source character set except new-line and "
pp-number:
   digit
   . digit
   pp-number digit
   pp-number identifier-nondigit
   pp-number [Ee] sign
   pp-number .
identifier:
   identifier-nondigit
   identifier identifier-nondigit
   identifier digit
identifier-nondigit:
   nondigit
   universal-character-name
   other implementation-defined characters
nondigit: [_A-Za-z]
digit: [0-9]
preprocessing-op-or-punc: one of
   {   }   [   ]   #   ##  (   )
   <:  :>  <%  %>  %: %:%: ;   :  ...
   new delete  ?   ::  .   .*
   +   -   *   /   %   ˆ   &   |   ~
   !   =   <   >   +=  -=  *=  /=  %=
   ˆ=  &=  |=  <<  >>  >>= <<= ==  !=
   <=  >=  &&  ||  ++  --  ,   ->* ->
   and and_eq bitand bitor compl not not_eq
   or  or_eq xor xor_eq
literal:
   integer-literal
   character-literal
   floating-literal
   string-literal
   boolean-literal
   pointer-literal
   user-defined-literal
integer-literal:
   decimal-literal integer-suffix(opt)
   octal-literal integer-suffix(opt)
   hexadecimal-literal integer-suffix(opt)
decimal-literal:
   nonzero-digit
   decimal-literal digit
octal-literal:
   0
   octal-literal octal-digit
hexadecimal-literal:
   0x hexadecimal-digit
   0X hexadecimal-digit
   hexadecimal-literal hexadecimal-digit
nonzero-digit: [1-9]
octal-digit: [0-7]
hexadecimal-digit: [0-9a-fA-F]
integer-suffix:
   unsigned-suffix long-suffix(opt)
   unsigned-suffix long-long-suffix(opt)
   long-suffix unsigned-suffix(opt)
   long-long-suffix unsigned-suffix(opt)
unsigned-suffix: [uU]
long-suffix: [lL]
long-long-suffix: [llLL]
character-literal:
   ' c-char-sequence '
   u' c-char-sequence '
   U' c-char-sequence '
   L' c-char-sequence '
c-char-sequence:
   c-char
   c-char-sequence c-char
c-char:
   any member of the source character set except the single-quote ', backslash \, or new-line
      character
   escape-sequence
   universal-character-name
escape-sequence:
   simple-escape-sequence
   octal-escape-sequence
   hexadecimal-escape-sequence
simple-escape-sequence: one of
   \' \" \? \\
   \a \b \f \n \r \t \v
octal-escape-sequence:
   \ octal-digit
   \ octal-digit octal-digit
   \ octal-digit octal-digit octal-digit
hexadecimal-escape-sequence:
   \x hexadecimal-digit
   hexadecimal-escape-sequence hexadecimal-digit
floating-literal:
   fractional-constant exponent-part(opt) floating-suffix(opt)
   digit-sequence exponent-part floating-suffix(opt)
fractional-constant:
   digit-sequence(opt) . digit-sequence
   digit-sequence .
exponent-part:
   [Ee] sign(opt) digit-sequence
sign: [-+]
digit-sequence:
   digit
   digit-sequence digit
floating-suffix: [flFL]
string-literal:
   encoding-prefix(opt) " s-char-sequence(opt) "
   encoding-prefix(opt) R raw-string
encoding-prefix:
   u8 u U L
s-char-sequence:
   s-char
   s-char-sequence s-char
s-char:
   any member of the source character set except
   the double-quote ", backslash \, or new-line character
   escape-sequence
   universal-character-name
raw-string:
   " d-char-sequence(opt) ( r-char-sequence(opt) ) d-char-sequence(opt) "
r-char-sequence:
   r-char
   r-char-sequence r-char
r-char:
   any member of the source character set, except a right parenthesis ) followed by the initial
      d-char-sequence (which may be empty) followed by a double quote ".
d-char-sequence:
   d-char
   d-char-sequence d-char
d-char:
   any member of the basic source character set except:
      space, the left parenthesis (, the right parenthesis ), the backslash \, and the control
      characters representing horizontal tab, vertical tab, form feed, and newline.
boolean-literal:
   false
   true
pointer-literal:
   nullptr
user-defined-literal:
   user-defined-integer-literal
   user-defined-floating-literal
   user-defined-string-literal
   user-defined-character-literal
user-defined-integer-literal:
   decimal-literal ud-suffix
   octal-literal ud-suffix
   hexadecimal-literal ud-suffix
user-defined-floating-literal:
   fractional-constant exponent-part(opt) ud-suffix
   digit-sequence exponent-part ud-suffix
user-defined-string-literal:
   string-literal ud-suffix
user-defined-character-literal:
   character-literal ud-suffix
ud-suffix:
   identifier
translation-unit:
   declaration-seq(opt)
primary-expression:
   literal
   this
   ( expression )
   id-expression
   lambda-expression
id-expression:
   unqualified-id
   qualified-id
unqualified-id:
   identifier
   operator-function-id
   conversion-function-id
   literal-operator-id
   ~ class-name
   ~ decltype-specifier
   template-id
qualified-id:
   ::(opt) nested-name-specifier template(opt) unqualified-id
   :: identifier
   :: operator-function-id
   :: literal-operator-id
   :: template-id
nested-name-specifier:
   type-name ::
   namespace-name ::
   decltype-specifier ::
   nested-name-specifier identifier ::
   nested-name-specifier template(opt) simple-template-id ::
lambda-expression:
   lambda-introducer lambda-declarator(opt) compound-statement
lambda-introducer:
   [ lambda-capture(opt) ]
lambda-capture:
   capture-default
   capture-list
   capture-default , capture-list
capture-default:
   &
   =
capture-list:
   capture ...(opt)
   capture-list , capture ...(opt)
capture:
   identifier
   & identifier
   this
lambda-declarator:
   ( parameter-declaration-clause ) mutable(opt)
   exception-specification(opt) attribute-specifier-seq(opt) trailing-return-type(opt)
postfix-expression:
   primary-expression
   postfix-expression [ expression ]
   postfix-expression [ braced-init-list ]
   postfix-expression ( expression-list(opt) )
   simple-type-specifier ( expression-list(opt) )
   typename-specifier ( expression-list(opt) )
   simple-type-specifier braced-init-list
   typename-specifier braced-init-list
   postfix-expression . template(opt) id-expression
   postfix-expression -> template(opt) id-expression
   postfix-expression . pseudo-destructor-name
   postfix-expression -> pseudo-destructor-name
   postfix-expression ++
   postfix-expression --
   dynamic_cast < type-id > ( expression )
   static_cast < type-id > ( expression )
   reinterpret_cast < type-id > ( expression )
   const_cast < type-id > ( expression )
   typeid ( expression )
   typeid ( type-id )
expression-list:
   initializer-list
pseudo-destructor-name:
   ::(opt) nested-name-specifier(opt) type-name :: ~ type-name
   ::(opt) nested-name-specifier template simple-template-id :: ~ type-name
   ::(opt) nested-name-specifier(opt) ~ type-name
   ~ decltype-specifier
unary-expression:
   postfix-expression
   ++ cast-expression
   -- cast-expression
   unary-operator cast-expression
   sizeof unary-expression
   sizeof ( type-id )
   sizeof ... ( identifier )
   alignof ( type-id )
   noexcept-expression
   new-expression
   delete-expression
unary-operator: one of
   * & + - ! ~
new-expression:
   ::(opt) new new-placement(opt) new-type-id new-initializer(opt)
   ::(opt) new new-placement(opt) ( type-id ) new-initializer(opt)
new-placement:
   ( expression-list )
new-type-id:
   type-specifier-seq new-declarator(opt)
new-declarator:
   ptr-operator new-declarator(opt)
   noptr-new-declarator
noptr-new-declarator:
   [ expression ] attribute-specifier-seq(opt)
   noptr-new-declarator [ constant-expression ] attribute-specifier-seq(opt)
new-initializer:
   ( expression-list(opt) )
   braced-init-list
delete-expression:
   ::(opt) delete cast-expression
   ::(opt) delete [ ] cast-expression
noexcept-expression:
   noexcept ( expression )
cast-expression:
   unary-expression
   ( type-id ) cast-expression
pm-expression:
   cast-expression
   pm-expression .* cast-expression
   pm-expression ->* cast-expression
multiplicative-expression:
   pm-expression
   multiplicative-expression * pm-expression
   multiplicative-expression / pm-expression
   multiplicative-expression % pm-expression
additive-expression:
   multiplicative-expression
   additive-expression + multiplicative-expression
   additive-expression - multiplicative-expression
shift-expression:
   additive-expression
   shift-expression << additive-expression
   shift-expression >> additive-expression
relational-expression:
   shift-expression
   relational-expression < shift-expression
   relational-expression > shift-expression
   relational-expression <= shift-expression
   relational-expression >= shift-expression
equality-expression:
   relational-expression
   equality-expression == relational-expression
   equality-expression != relational-expression
and-expression:
   equality-expression
   and-expression & equality-expression
exclusive-or-expression:
   and-expression
   exclusive-or-expression ˆ and-expression
inclusive-or-expression:
   exclusive-or-expression
   inclusive-or-expression | exclusive-or-expression
logical-and-expression:
   inclusive-or-expression
   logical-and-expression && inclusive-or-expression
logical-or-expression:
   logical-and-expression
   logical-or-expression || logical-and-expression
conditional-expression:
   logical-or-expression
   logical-or-expression ? expression : assignment-expression
assignment-expression:
   conditional-expression
   logical-or-expression assignment-operator initializer-clause
   throw-expression
assignment-operator: one of
   = *= /= %= += -= >>= <<= &= ˆ= |=
expression:
   assignment-expression
   expression , assignment-expression
constant-expression:
   conditional-expression
statement:
   labeled-statement
   attribute-specifier-seq(opt) expression-statement
   attribute-specifier-seq(opt) compound-statement
   attribute-specifier-seq(opt) selection-statement
   attribute-specifier-seq(opt) iteration-statement
   attribute-specifier-seq(opt) jump-statement
   declaration-statement
   attribute-specifier-seq(opt) try-block
labeled-statement:
   attribute-specifier-seq(opt) identifier : statement
   attribute-specifier-seq(opt) case constant-expression : statement
   attribute-specifier-seq(opt) default : statement
expression-statement:
   expression(opt) ;
compound-statement:
   { statement-seq(opt) }
statement-seq:
   statement
   statement-seq statement
selection-statement:
   if ( condition ) statement
   if ( condition ) statement else statement
   switch ( condition ) statement
condition:
   expression
   attribute-specifier-seq(opt) decl-specifier-seq declarator = initializer-clause
   attribute-specifier-seq(opt) decl-specifier-seq declarator braced-init-list
iteration-statement:
   while ( condition ) statement
   do statement while ( expression ) ;
   for ( for-init-statement condition(opt) ; expression(opt) ) statement
   for ( for-range-declaration : for-range-initializer ) statement
for-init-statement:
   expression-statement
   simple-declaration
for-range-declaration:
   attribute-specifier-seq(opt) type-specifier-seq declarator
for-range-initializer:
   expression
   braced-init-list
jump-statement:
   break ;
   continue ;
   return expression(opt) ;
   return braced-init-list ;
   goto identifier ;
declaration-statement:
   block-declaration
declaration-seq:
   declaration
   declaration-seq declaration
declaration:
   block-declaration
   function-definition
   template-declaration
   explicit-instantiation
   explicit-specialization
   linkage-specification
   namespace-definition
   empty-declaration
   attribute-declaration
block-declaration:
   simple-declaration
   asm-definition
   namespace-alias-definition
   using-declaration
   using-directive
   static_assert-declaration
   alias-declaration
   opaque-enum-declaration
alias-declaration:
   using identifier = type-id ;
simple-declaration:
   attribute-specifier-seq(opt) decl-specifier-seq(opt) init-declarator-list(opt) ;
static_assert-declaration:
   static_assert ( constant-expression , string-literal ) ;
empty-declaration:
   ;
attribute-declaration:
   attribute-specifier-seq ;
decl-specifier:
   storage-class-specifier
   type-specifier
   function-specifier
   friend
   typedef
   constexpr
decl-specifier-seq:
   decl-specifier attribute-specifier-seq(opt)
   decl-specifier decl-specifier-seq
storage-class-specifier:
   register
   static
   thread_local
   extern
   mutable
function-specifier:
   inline
   virtual
   explicit
typedef-name:
   identifier
type-specifier:
   trailing-type-specifier
   class-specifier
   enum-specifier
trailing-type-specifier:
   simple-type-specifier
   elaborated-type-specifier
   typename-specifier
   cv-qualifier
type-specifier-seq:
   type-specifier attribute-specifier-seq(opt)
   type-specifier type-specifier-seq
trailing-type-specifier-seq:
   trailing-type-specifier attribute-specifier-seq(opt)
   trailing-type-specifier trailing-type-specifier-seq
simple-type-specifier:
   ::(opt) nested-name-specifier(opt) type-name
   ::(opt) nested-name-specifier template simple-template-id
   char
   char16_t
   char32_t
   wchar_t
   bool
   short
   int
   long
   signed
   unsigned
   float
   double
   void
   auto
   decltype-specifier
type-name:
   class-name
   enum-name
   typedef-name
   simple-template-id
decltype-specifier:
   decltype ( expression )
elaborated-type-specifier:
   class-key attribute-specifier-seq(opt) ::(opt) nested-name-specifier(opt) identifier
   class-key ::(opt) nested-name-specifier(opt) template(opt) simple-template-id
   enum ::(opt) nested-name-specifier(opt) identifier
enum-name:
   identifier
enum-specifier:
   enum-head { enumerator-list(opt) }
   enum-head { enumerator-list , }
enum-head:
   enum-key attribute-specifier-seq(opt) identifier(opt) enum-base(opt)
   enum-key attribute-specifier-seq(opt) nested-name-specifier identifier
   enum-base(opt)
opaque-enum-declaration:
   enum-key attribute-specifier-seq(opt) identifier enum-base(opt) ;
enum-key:
   enum
   enum class
   enum struct
enum-base:
   : type-specifier-seq
enumerator-list:
   enumerator-definition
   enumerator-list , enumerator-definition
enumerator-definition:
   enumerator
   enumerator = constant-expression
enumerator:
   identifier
namespace-name:
   original-namespace-name
   namespace-alias
original-namespace-name:
   identifier
namespace-definition:
   named-namespace-definition
   unnamed-namespace-definition
named-namespace-definition:
   original-namespace-definition
   extension-namespace-definition
original-namespace-definition:
   inline(opt) namespace identifier { namespace-body }
extension-namespace-definition:
   inline(opt) namespace original-namespace-name { namespace-body }
unnamed-namespace-definition:
   inline(opt) namespace { namespace-body }
namespace-body:
   declaration-seq(opt)
namespace-alias:
   identifier
namespace-alias-definition:
namespace identifier = qualified-namespace-specifier ;
qualified-namespace-specifier:
   ::(opt) nested-name-specifier(opt) namespace-name
using-declaration:
   using typename(opt) ::(opt) nested-name-specifier unqualified-id ;
   using :: unqualified-id ;
using-directive:
   attribute-specifier-seq(opt) using namespace ::(opt) nested-name-specifier(opt) namespace-name ;
asm-definition:
   asm ( string-literal ) ;
linkage-specification:
   extern string-literal { declaration-seq(opt) }
   extern string-literal declaration
attribute-specifier-seq:
   attribute-specifier-seq(opt) attribute-specifier
attribute-specifier:
   [ [ attribute-list ] ]
   alignment-specifier
alignment-specifier:
   alignas ( type-id ...(opt) )
   alignas ( alignment-expression ...(opt) )
attribute-list:
   attribute(opt)
   attribute-list , attribute(opt)
   attribute ...
   attribute-list , attribute ...
attribute:
   attribute-token attribute-argument-clause(opt)
attribute-token:
   identifier
   attribute-scoped-token
attribute-scoped-token:
   attribute-namespace :: identifier
   attribute-namespace:
   identifier
attribute-argument-clause:
   ( balanced-token-seq )
balanced-token-seq:
   balanced-token
   balanced-token-seq balanced-token
balanced-token:
   ( balanced-token-seq )
   [ balanced-token-seq ]
   { balanced-token-seq }
   any token other than a parenthesis, a bracket, or a brace
init-declarator-list:
   init-declarator
   init-declarator-list , init-declarator
init-declarator:
   declarator initializer(opt)
declarator:
   ptr-declarator
   noptr-declarator parameters-and-qualifiers trailing-return-type
ptr-declarator:
   noptr-declarator
   ptr-operator ptr-declarator
noptr-declarator:
   declarator-id attribute-specifier-seq(opt)
   noptr-declarator parameters-and-qualifiers
   noptr-declarator [ constant-expression(opt) ] attribute-specifier-seq(opt)
   ( ptr-declarator )
parameters-and-qualifiers:
   ( parameter-declaration-clause ) attribute-specifier-seq(opt) cv-qualifier-seq(opt)
   ref-qualifier(opt) exception-specification(opt)
trailing-return-type:
   -> trailing-type-specifier-seq abstract-declarator(opt)
ptr-operator:
   * attribute-specifier-seq(opt) cv-qualifier-seq(opt)
   & attribute-specifier-seq(opt)
   && attribute-specifier-seq(opt)
   ::(opt) nested-name-specifier * attribute-specifier-seq(opt) cv-qualifier-seq(opt)
cv-qualifier-seq:
   cv-qualifier cv-qualifier-seq(opt)
cv-qualifier:
   const
   volatile
ref-qualifier:
   &
   &&
declarator-id:
   ...(opt) id-expression
   ::(opt) nested-name-specifier(opt) class-name
type-id:
   type-specifier-seq abstract-declarator(opt)
abstract-declarator:
   ptr-abstract-declarator
   noptr-abstract-declarator(opt) parameters-and-qualifiers trailing-return-type
   ...
ptr-abstract-declarator:
   noptr-abstract-declarator
   ptr-operator ptr-abstract-declarator(opt)
noptr-abstract-declarator:
   noptr-abstract-declarator(opt) parameters-and-qualifiers
   noptr-abstract-declarator(opt) [ constant-expression ] attribute-specifier-seq(opt)
   ( ptr-abstract-declarator )
parameter-declaration-clause:
   parameter-declaration-list(opt) ...(opt)
   parameter-declaration-list , ...
parameter-declaration-list:
   parameter-declaration
   parameter-declaration-list , parameter-declaration
parameter-declaration:
   attribute-specifier-seq(opt) decl-specifier-seq declarator
   attribute-specifier-seq(opt) decl-specifier-seq declarator = initializer-clause
   attribute-specifier-seq(opt) decl-specifier-seq abstract-declarator(opt)
   attribute-specifier-seq(opt) decl-specifier-seq abstract-declarator(opt) = initializer-clause
function-definition:
   attribute-specifier-seq(opt) decl-specifier-seq(opt) declarator function-body
   attribute-specifier-seq(opt) decl-specifier-seq(opt) declarator = default ;
   attribute-specifier-seq(opt) decl-specifier-seq(opt) declarator = delete ;
function-body:
   ctor-initializer(opt) compound-statement
   function-try-block
initializer:
   brace-or-equal-initializer
   ( expression-list )
brace-or-equal-initializer:
   = initializer-clause
   braced-init-list
initializer-clause:
   assignment-expression
   braced-init-list
initializer-list:
   initializer-clause ...(opt)
   initializer-list , initializer-clause ...(opt)
braced-init-list:
   { initializer-list ,(opt) }
   {}
class-name:
   identifier
   simple-template-id
class-specifier:
   class-head { member-specification(opt) }
class-head:
   class-key attribute-specifier-seq(opt) class-head-name class-virt-specifier-seq(opt) base-clause(opt)
   class-key attribute-specifier-seq(opt) base-clause(opt)
class-head-name:
   nested-name-specifier(opt) class-name
class-virt-specifier-seq:
   class-virt-specifier
   class-virt-specifier-seq class-virt-specifier
class-virt-specifier:
   final
   explicit
class-key:
   class
   struct
   union
member-specification:
   member-declaration member-specification(opt)
   access-specifier : member-specification(opt)
member-declaration:
   attribute-specifier-seq(opt) decl-specifier-seq(opt)
   member-declarator-list(opt) ;
   function-definition ;(opt)
   using-declaration
   static_assert-declaration
   template-declaration
   alias-declaration
member-declarator-list:
   member-declarator
   member-declarator-list , member-declarator
member-declarator:
   declarator virt-specifier-seq(opt) pure-specifier(opt)
   declarator virt-specifier-seq(opt) brace-or-equal-initializer(opt)
   identifier(opt) attribute-specifier-seq(opt) virt-specifier-seq(opt) : constant-expression
virt-specifier-seq:
   virt-specifier
   virt-specifier-seq virt-specifier
virt-specifier:
   override
   final
   new
pure-specifier:
   = 0
base-clause:
   : base-specifier-list
base-specifier-list:
   base-specifier ...(opt)
   base-specifier-list , base-specifier ...(opt)
base-specifier:
   attribute-specifier-seq(opt) base-type-specifier
   attribute-specifier-seq(opt) virtual access-specifier(opt) base-type-specifier
   attribute-specifier-seq(opt) access-specifier virtual(opt) base-type-specifier
class-or-decltype:
   ::(opt) nested-name-specifier(opt) class-name
   decltype-specifier
base-type-specifier:
   class-or-decltype
access-specifier:
   private
   protected
   public
conversion-function-id:
   operator conversion-type-id
conversion-type-id:
   type-specifier-seq conversion-declarator(opt)
conversion-declarator:
   ptr-operator conversion-declarator(opt)
ctor-initializer:
   : mem-initializer-list
mem-initializer-list:
   mem-initializer ...(opt)
   mem-initializer , mem-initializer-list ...(opt)
mem-initializer:
   mem-initializer-id ( expression-list(opt) )
   mem-initializer-id braced-init-list
mem-initializer-id:
   class-or-decltype
   identifier
operator-function-id:
   operator operator
operator: one of
   new delete new[] delete[]
   +  -  *  /  %  ˆ   &   |   ∼
   !  =  <  >  += -=  *=  /=  %=
   ˆ= &= |= << >> >>= <<= ==  !=
   <= >= && || ++ --  ,   ->* ->
   () []
literal-operator-id:
   operator "" identifier
template-declaration:
   template < template-parameter-list > declaration
template-parameter-list:
   template-parameter
   template-parameter-list , template-parameter
template-parameter:
   type-parameter
   parameter-declaration
type-parameter:
   class ...(opt) identifier(opt)
   class identifier(opt) = type-id
   typename ...(opt) identifier(opt)
   typename identifier(opt) = type-id
   template < template-parameter-list > class ...(opt) identifier(opt)
   template < template-parameter-list > class identifier(opt) = id-expression
simple-template-id:
   template-name < template-argument-list(opt) >
template-id:
   simple-template-id
   operator-function-id < template-argument-list(opt) >
   literal-operator-id < template-argument-list(opt) >
template-name:
   identifier
template-argument-list:
   template-argument ...(opt)
   template-argument-list , template-argument ...(opt)
template-argument:
   constant-expression
   type-id
   id-expression
typename-specifier:
   typename ::(opt) nested-name-specifier identifier
   typename ::(opt) nested-name-specifier template(opt) simple-template-id
explicit-instantiation:
   extern(opt) template declaration
explicit-specialization:
   template < > declaration
try-block:
   try compound-statement handler-seq
function-try-block:
   try ctor-initializer(opt) compound-statement handler-seq
handler-seq:
   handler handler-seq(opt)
handler:
   catch ( exception-declaration ) compound-statement
exception-declaration:
   attribute-specifier-seq(opt) type-specifier-seq declarator
   attribute-specifier-seq(opt) type-specifier-seq abstract-declarator(opt)
   ...
throw-expression:
   throw assignment-expression(opt)
exception-specification:
   dynamic-exception-specification
   noexcept-specification
dynamic-exception-specification:
   throw ( type-id-list(opt) )
type-id-list:
   type-id ...(opt)
   type-id-list , type-id ...(opt)
noexcept-specification:
   noexcept ( constant-expression )
   noexcept
preprocessing-file:
   group(opt)
group:
   group-part
   group group-part
group-part:
   if-section
   control-line
   text-line
   # non-directive
if-section:
   if-group elif-groups(opt) else-group(opt) endif-line
if-group:
   # if constant-expression new-line group(opt)
   # ifdef identifier new-line group(opt)
   # ifndef identifier new-line group(opt)
elif-groups:
   elif-group
   elif-groups elif-group
elif-group:
   # elif constant-expression new-line group(opt)
else-group:
   # else new-line group(opt)
endif-line:
   # endif new-line
control-line:
   # include pp-tokens new-line
   # define identifier replacement-list new-line
   # define identifier lparen identifier-list(opt) ) replacement-list new-line
   # define identifier lparen ... ) replacement-list new-line
   # define identifier lparen identifier-list, ... ) replacement-list new-line
   # undef identifier new-line
   # line pp-tokens new-line
   # error pp-tokens(opt) new-line
   # pragma pp-tokens(opt) new-line
   # new-line
text-line:
   pp-tokens(opt) new-line
non-directive:
   pp-tokens new-line
lparen:
   a ( character not immediately preceded by white-space
identifier-list:
   identifier
   identifier-list , identifier
replacement-list:
   pp-tokens(opt)
pp-tokens:
   preprocessing-token
   pp-tokens preprocessing-token
new-line:
   the new-line character

